package middleware

import (
	"bytes"
	"io"
	"net/http"
	"sync"
	"time"

	"{{.Module}}/pkg/internal/identity"
	"{{.Module}}/pkg/internal/log"
	"{{.Module}}/pkg/internal/result"

	"github.com/go-chi/chi/v5/middleware"
	"github.com/pkg/errors"
	"github.com/shenghui0779/yiigo"
	"github.com/tidwall/pretty"
	"go.uber.org/zap"
)

const MaxBodyLogSize = 20 << 10 // 20KB

var bufPool = sync.Pool{
	New: func() any {
		return bytes.NewBuffer(make([]byte, 0, 4<<10)) // 4KB
	},
}

// Log 日志中间件
func Log(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		now := time.Now()
		body := "<nil>"

		var err error

		buf := bufPool.Get().(*bytes.Buffer)
		buf.Reset()
		defer bufPool.Put(buf)
		// 自定义响应
		ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)
		ww.Tee(buf)

		// 记录日志
		defer func() {
			fields := make([]zap.Field, 0, 10)
			fields = append(fields,
				zap.String("method", r.Method),
				zap.String("path", r.URL.Path),
				zap.String("ip", r.RemoteAddr),
				zap.Any("header", r.Header),
				zap.String("req_body", body),
			)
			// 响应体
			respSize := buf.Len()
			if respSize <= MaxBodyLogSize {
				fields = append(fields, zap.String("resp_body", buf.String()))
			} else {
				fields = append(fields, zap.String("resp_body", "body too large"))
			}
			fields = append(fields, zap.Int("resp_size", respSize))
			// 错误
			if err != nil {
				fields = append(fields, zap.String("err_body", err.Error()))
			}
			fields = append(fields,
				zap.String("identity", identity.FromContext(r.Context()).String()),
				zap.Int("status", ww.Status()),
				zap.String("duration", time.Since(now).String()),
			)
			log.Info(r.Context(), "request log", fields...)
		}()

		// 请求包含body
		if r.Body != nil && r.Body != http.NoBody {
			switch yiigo.ContentType(r.Header) {
			case yiigo.ContentForm:
				if _err := r.ParseForm(); _err != nil {
					err = errors.WithMessage(_err, "Form解析失败")
					result.ErrSystem(result.E(err)).JSON(w, r)
					return
				}
				body = r.Form.Encode()
			case yiigo.ContentFormMultipart:
				if _err := r.ParseMultipartForm(yiigo.MaxFormMemory); _err != nil {
					if _err != http.ErrNotMultipart {
						err = errors.WithMessage(_err, "MultipartForm解析失败")
						result.ErrSystem(result.E(err)).JSON(w, r)
						return
					}
				}
				body = r.Form.Encode()
			case yiigo.ContentJSON:
				b, _err := io.ReadAll(r.Body) // 取出Body
				if _err != nil {
					err = errors.WithMessage(_err, "请求Body读取失败")
					result.ErrSystem(result.E(err)).JSON(w, r)
					return
				}
				_ = r.Body.Close() // 关闭原Body
				body = string(pretty.Ugly(b))
				// 重置Body
				r.Body = io.NopCloser(bytes.NewReader(b))
			}
		}

		next.ServeHTTP(ww, r)
	})
}
