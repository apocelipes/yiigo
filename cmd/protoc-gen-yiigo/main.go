package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "v1.0.0"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-yiigo %v\n", version)
		return
	}

	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(p *protogen.Plugin) error {
		p.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range p.Files {
			if !f.Generate {
				continue
			}
			generateFile(p, f)
		}
		return nil
	})
}

const (
	contextPkg = protogen.GoImportPath("context")
	errorPkg   = protogen.GoImportPath("errors")
	httpPkg    = protogen.GoImportPath("net/http")
	chiPkg     = protogen.GoImportPath("github.com/go-chi/chi/v5")
	contribPkg = protogen.GoImportPath("github.com/yiigo/contrib")
	resultPkg  = protogen.GoImportPath("github.com/yiigo/contrib/result")
)

// generateFile generates a _http.pb.go file containing HTTP service definitions.
func generateFile(p *protogen.Plugin, f *protogen.File) *protogen.GeneratedFile {
	if len(f.Services) == 0 {
		return nil
	}
	filename := f.GeneratedFilenamePrefix + "_http.pb.go"
	gf := p.NewGeneratedFile(filename, f.GoImportPath)
	gf.P("// Code generated by protoc-gen-yiigo. DO NOT EDIT.")
	gf.P("// versions:")
	gf.P("// - protoc-gen-yiigo ", version)
	gf.P("// - protoc           ", protocVersion(p))
	if f.Proto.GetOptions().GetDeprecated() {
		gf.P("// ", f.Desc.Path(), " is a deprecated f.")
	} else {
		gf.P("// source: ", f.Desc.Path())
	}
	gf.P()
	gf.P("package ", f.GoPackageName)
	gf.P()
	generateFileContent(f, gf)
	return gf
}

func protocVersion(p *protogen.Plugin) string {
	v := p.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// generateFileContent generates the HTTP service definitions, excluding the package statement.
func generateFileContent(f *protogen.File, gf *protogen.GeneratedFile) {
	if len(f.Services) == 0 {
		return
	}
	for _, service := range f.Services {
		genService(gf, service)
	}
}

func genService(gf *protogen.GeneratedFile, service *protogen.Service) {
	serviceType := "Http" + service.GoName
	// Server interface.
	_genInterface(gf, service, serviceType)
	gf.P()
	// Unimplemented server.
	_genUnimplement(gf, service, serviceType)
	gf.P()
	// Register service HttpServer.
	_genRegister(gf, service, serviceType)
	gf.P()
	// Register service methods.
	_genMethods(gf, service, serviceType)
}

// Method(ctx context.Context, req *MethodReq) (*MethodResp, error)
func signature(gf *protogen.GeneratedFile, method *protogen.Method) string {
	var reqArgs []string
	// params
	reqArgs = append(reqArgs, "ctx "+gf.QualifiedGoIdent(contextPkg.Ident("Context")))
	reqArgs = append(reqArgs, "req *"+gf.QualifiedGoIdent(method.Input.GoIdent))
	// return
	resp := "(*" + gf.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + resp
}

func _genInterface(gf *protogen.GeneratedFile, service *protogen.Service, serviceType string) {
	gf.P("// ", serviceType, " is the API definition for ", service.GoName)
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		gf.P("//")
	}
	gf.AnnotateSymbol(serviceType, protogen.Annotation{Location: service.Location})
	// type HttpXXX interface {
	gf.P("type ", serviceType, " interface {")
	for _, m := range service.Methods {
		if m.Desc.IsStreamingClient() || m.Desc.IsStreamingServer() {
			continue
		}
		gf.AnnotateSymbol(serviceType+"."+m.GoName, protogen.Annotation{Location: m.Location})
		if m.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
		}
		gf.P(m.Comments.Leading, signature(gf, m))
	}
	gf.P("}")
}

func _genUnimplement(gf *protogen.GeneratedFile, service *protogen.Service, serviceType string) {
	gf.P("// Unimplemented", serviceType, " should be embedded to have")
	gf.P("// forward compatible implementations.")
	gf.P("//")
	gf.P("// NOTE: this should be embedded by value instead of pointer to avoid a nil")
	gf.P("// pointer dereference when methods are called.")
	gf.P("type Unimplemented", serviceType, " struct{}")
	for _, m := range service.Methods {
		gf.P()
		gf.P("func (Unimplemented", serviceType, ") ", m.GoName, "(context.Context, *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", error) {")
		gf.P(`return nil, `, errorPkg.Ident("New"), `("method `, m.GoName, ` not implemented")`)
		gf.P("}")
	}
}

func _genRegister(gf *protogen.GeneratedFile, service *protogen.Service, serviceType string) {
	gf.P("func Register", serviceType, "(r ", chiPkg.Ident("Router"), ", svc ", serviceType, ") {")
	for _, m := range service.Methods {
		rule, ok := proto.GetExtension(m.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
		if rule != nil && ok {
			method, path := getHttpRouter(rule)
			gf.P(strings.TrimSuffix(m.Comments.Leading.String(), "\n"))
			gf.P("r.", method, `("`, path, `", _`, service.GoName, "_", m.GoName, `(svc))`)
			// additional bindings
			for _, bind := range rule.AdditionalBindings {
				method, path := getHttpRouter(bind)
				gf.P("r.", method, `("`, path, `", _`, service.GoName, "_", m.GoName, `(svc))`)
			}
		}
	}
	gf.P("}")
}

func _genMethods(gf *protogen.GeneratedFile, service *protogen.Service, serviceType string) {
	for _, m := range service.Methods {
		gf.P("func _", service.GoName, "_", m.GoName, "(svc ", serviceType, ") http.HandlerFunc {")
		gf.P("return func(w ", httpPkg.Ident("ResponseWriter"), ", r *", httpPkg.Ident("Request"), ") {")
		gf.P("ctx := r.Context()")
		gf.P("// parse request")
		gf.P("req := new(", m.Input.GoIdent, ")")
		gf.P("if err := ", contribPkg.Ident("BindProto"), "(r, req); err != nil {")
		gf.P(resultPkg.Ident("Err"), `(err).JSON(w, r)`)
		gf.P("return")
		gf.P("}")
		gf.P("// call service")
		gf.P("resp, err := svc.", m.GoName, "(ctx, req)")
		gf.P("if err != nil {")
		gf.P(resultPkg.Ident("Err"), "(err).JSON(w, r)")
		gf.P("return")
		gf.P("}")
		gf.P(resultPkg.Ident("OK"), "(resp).JSON(w, r)")
		gf.P("}")
		gf.P("}")
	}
}

func getHttpRouter(rule *annotations.HttpRule) (string, string) {
	switch v := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		return "Get", v.Get
	case *annotations.HttpRule_Put:
		return "Put", v.Put
	case *annotations.HttpRule_Post:
		return "Post", v.Post
	case *annotations.HttpRule_Delete:
		return "Delete", v.Delete
	case *annotations.HttpRule_Patch:
		return "Patch", v.Patch
	case *annotations.HttpRule_Custom:
		return v.Custom.GetKind(), v.Custom.GetPath()
	}
	return "Unknown", ""
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }
